# Actividad 5.2 – Resultados de pruebas y verificación

## Programa: computeSales.py

Cumplimiento de requisitos:
- **Req1**: Invocación por línea de comandos con dos archivos (catálogo JSON y registro de ventas JSON).
- **Req2**: Cálculo del coste total de todas las ventas; salida en pantalla y en `SalesResults.txt`; formato legible.
- **Req3**: Manejo de datos inválidos: errores en consola y ejecución continúa.
- **Req4**: Nombre del programa: `computeSales.py`.
- **Req5**: Invocación mínima: `python computeSales.py priceCatalogue.json salesRecord.json`.
- **Req6**: Diseño adecuado para archivos con cientos/miles de ítems (procesamiento en memoria con estructuras eficientes).
- **Req7**: Tiempo de ejecución al final en resultados y en pantalla.
- **Req8**: Cumplimiento PEP8 (verificado con flake8).

---

## Estructura del proyecto (según carpeta de referencia A5.2 Archivos de Apoyo)

```
5.2/
├── source/
│   └── computeSales.py
├── TC1/
│   ├── TC1.ProductList.json   # Catálogo de precios (obligatorio para TC1)
│   └── TC1.Sales.json         # Registro de ventas
├── TC2/
│   └── TC2.Sales.json         # Ventas (usar catálogo de TC1)
├── TC3/
│   └── TC3.Sales.json         # Ventas (usar catálogo de TC1)
├── Results.txt                # Totales de referencia (TC1, TC2, TC3)
└── ProductList.csv            # Referencia (opcional; el programa usa JSON)
```

## Formato de archivos JSON

- **Catálogo de precios**: array JSON de objetos con `"title"` y `"price"` (p. ej. TC1.ProductList.json).
- **Registro de ventas** (dos formatos soportados):
  1. **Formato plano (referencia)**: array de objetos con `SALE_ID`, `Product`, `Quantity` (y opcionalmente `SALE_Date`). Se agrupa por `SALE_ID` para calcular el total por venta.
  2. **Formato anidado**: array de ventas con `"items"`: array de `{"product": "...", "quantity": N}`.

---

## Pruebas de ejecución

### Con archivos de referencia (TC1, TC2, TC3)

Desde `source/`:

```bash
# TC1: catálogo y ventas en TC1
python computeSales.py ../TC1/TC1.ProductList.json ../TC1/TC1.Sales.json

# TC2 y TC3: mismo catálogo (TC1), distinto archivo de ventas
python computeSales.py ../TC1/TC1.ProductList.json ../TC2/TC2.Sales.json
python computeSales.py ../TC1/TC1.ProductList.json ../TC3/TC3.Sales.json
```

- **TC1**: GRAND TOTAL = 2481.86 (coincide con `Results.txt` de referencia).
- TC2 y TC3 usan el mismo catálogo; el total se escribe en pantalla y en `SalesResults.txt`.

### TC1 – Ejecución normal (datos válidos, ejemplo propio)

Comando:
```bash
python computeSales.py priceCatalogue.json salesRecord.json
```

Resultado: total correcto (121.97 con los datos de ejemplo), salida en pantalla y en `SalesResults.txt`, tiempo mostrado al final.

### TC2 – Datos inválidos (manejo de errores)

Comando:
```bash
python computeSales.py priceCatalogue.json ../tests/salesRecord_invalid.json
```

Resultado: se muestran en consola los avisos (producto no en catálogo, cantidad negativa, falta `quantity`); la ejecución continúa y se escribe el total parcial (19.98) en pantalla y en archivo.

---

## Flake8

Instalación (en entorno virtual recomendado):
```bash
python3 -m venv .venv
source .venv/bin/activate  # En Windows: .venv\Scripts\activate
pip install flake8
```

Ejecución:
```bash
flake8 source/computeSales.py
```

Resultado: **0 errores, 0 advertencias** (códigos E***/W***, F***, C9** sin incidencias).

---

## Pylint

Instalación (mismo venv):
```bash
pip install pylint
```

Ejecución:
```bash
pylint source/computeSales.py
```

Resultado: **10.00/10**. El nombre del módulo `computeSales` no sigue snake_case por requisito del enunciado (Req4); se usó `# pylint: disable=invalid-name` solo para ese caso.

---

## Resumen

- Programa implementado según especificación.
- Pruebas TC1 y TC2 ejecutadas y documentadas.
- Flake8 y Pylint ejecutados; código ajustado para cumplir PEP8 y sin problemas reportados por Pylint.
